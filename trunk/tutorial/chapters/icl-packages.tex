Chapter \ref{cha:features} listed basic features of the ICL packages that do not pertain to image processing in the proper meaning of the word. This chapter lists and explains most image processing functionalities and interfaces.

\section{ICLUtils}

[Documentation: \iclpackageref{Utils}]\\
This ICLUtils package contains (per definition) no image processing functions, rather it provides more general classes and functions (e.g. matrix and vector classes, exceptions, debugging macros etc.).

\subsection{Matrix and Vector Classes}
Matrix and Vector algebra is very common in a lot of applications. The ICL provides two approaches for matrix and vector classes:


\subsubsection{FixedMatrix Template Class\iclclassref{FixedMatrix}{Utils}}
This class uses three template parameters \inlinecode{template<class T, unsigned int COLS, unsigned} \inlinecode{int ROWS>} to represent matrices of fixed size. FixedVectors are implemented as shallow inheriting wrappers of FixedMatrix class instances with \inlinecode{COLS=1} (\inlinecode{FixedColVector}) or \inlinecode{ROWS=1} (\inlinecode{FixedRowVector})\footnote{This cannot be implemented using typedefs, because C++ does not support templated typedefs}.
By using \emph{templated} dimension parameters, matrix dimension is fixed at compilation time, which enables the compiler to apply a lot of optimizations. Most common vector and matrix algebra functionalities \footnote{As far as I can see, actually a super-set of BLAS-level 3}, including matrix mutliplication (scalar product is just a special case here), QR-Matrix decomposition and matrix inverse and pseudo-inverse\footnote{QR-decomposition-based} implementation. \inlinecode{FixedMatrix} instances resign smart data handling to enable the compiler to apply special optimizations on fixed arrays. In particular, temporary instances (and their data) can be allocated on the stack, rather than having to allocate data on the heap.
The \inlinecode{FixedMatrix} class provides row- and column iterators, as well as extraction functions for rows, columns or rectangular sub-matrices.
Here's a concise example:
\codefile{fixed-matrix-demo-1.cpp}{Example for usage of the \inlinecode{FixedMatrix}-template class}
Please note, that \inlinecode{FixedMatrix}-pseudo inverse calculation is out-sourced to a dedicated header \iclheaderref{Utils}{FixedMatrixUtils} to reduce complexity of the FixedMatrix header file.

\subsubsection{DynMatrix Template Class\iclclassref{DynMatrix}{Utils}}

In contrast to the \inlinecode{FixedMatrix} template class, the \inlinecode{DynMatrix} template class uses a single template parameter which defines the actual datatype of the matrix elements. Matrix dimensions are dynamic at runtime, which enables us to provide e.g. a \inlinecode{setBounds} member function. In addition, \inlinecode{DynMatrix} instances can be assigned with \inlinecode{DynMatrix} instances of another size. Dynamic sized data types need dynamic data handling\footnote{using \inlinecode{new []} and \inlinecode{delete []}}. This besides allows a more flexible mechanism: optional shallow data wrapping. \inlinecode{DynMatrix} instances can be set up to handle their data autonomously (using \inlinecode{new []} in the constructor and \inlinecode{delete []} in the destructor), or to \emph{count on} external data handling. Most other functionalities such as matrix multiplication or matrix inverse are also available here. Actually, matrix inverse in the \inlinecode{FixedMatrix} class is implemented by a shallow wrapping \inlinecode{DynMatrix} function call.\\
In addition to the actual \inlinecode{DynMatrix}-class, we provide another header file that is called \iclheaderref{Utils}{DynMatrixUtils}. This contains a large set of arithmetical functions in different calling manners (source-destination, source-only). Additionally \inlinecode{add}, \inlinecode{sub} and \inlinecode{mult} are provided multiple times to allow e.g. multiplication of two matrices A and B as $A^{\tau}B$ without the need to transpose A explicitly before.\\[10pt]
The \inlinecode{DynMatrix}-template class is very tightly integrated with the  \inlinecode{Img<T>}-template class. The index operator (\inlinecode{Img<T>::operator[](int channel)} returns an instance of \inlinecode{DynMatrix<T>} that wraps the images channel data shallowly. This enables the programmer switch between image- and matrix notation very easily. Besides \inlinecode{Img<T>} instances can be created as shallow wrappers of a set of \inlinecode{DynMatrix<T>}-instances (one \inlinecode{DynMatrix<T>}-instances corresponds to one image channel) by using an appropriate \inlinecode{Img<T>}-constructor, that takes up to 5 \inlinecode{DynMatrix<T>}-arguments.\\
This also allows the user to apply arbitrary image processing functions on \inlinecode{DynMatrix<T>} instances.




\subsection{Time and Timing classes}
ICL provides some time and timer classes to facilitate handling of time values and frame rates:
\begin{itemize}
\item The \inlinecode{Time} class (\iclclassref{Utils}{Time}) is the basis for timing classes. It provides a static function \inlinecode{now()} to obtain the current system time, as well as a variety manipulation and conversion functions.
\item The \inlinecode{Timer} (\iclclassref{Utils}{Timer}) class allows to compute time differences e.g. for benchmarking.
\item The \inlinecode{StackTimer} (\iclclassref{Utils}{StackTimer}) can be used with the macro \inlinecode{BENCHMARK\_THIS\_FUNCTION} to profile a function.
\item \inlinecode{FPSEstimator} (\iclclassref{Utils}{FPSEstimator}) and \inlinecode{FPSLimiter} (\iclclassref{Utils}{FPSLimiter}) can be used to compute or to limit the FPS\footnote{Frames Per Second} count of a application.
\end{itemize}

\subsection{Threading Classes}
The \inlinecode{Thread}-class (\iclclassref{Utils}{Thread}) and the \inlinecode{Mutex}-class (\iclclassref{Utils}{Mutex}) are simple object-oriented wrappers for the pthread library.

\subsection{ProgArg-Environment} 
As a lot of applications need to parse command line parameters, ICL provides a simple interface to define, explain, extract and parse command line arguments (\iclheaderref{Utils}{ProgArg}). Application arguments are always fixed and need to be accessible globally, so the program argument environment is  implemented as a set of global functions each having the \inlinecode{pa_}-prefix. \inlinecode{pa\_init()} can be used to define the list of allowed program arguments and their specific count of sub-arguments\footnote{E.g consider a program argument \inlinecode{-size} could be implemented with a single sub-argument: the size.}. \inlinecode{pa\_exmplain()} explains sub-arguments. \inlinecode{pa\_defined()} and \inlinecode{pa\_arg()} are used to obtain information of the actual given program arguments.  The \inlinecode{pa\_subarg()} template function can be used to extract and parse given sub-arguments e.g. as \inlinecode{int}:
\displaycode{int c = pa\_subarg<int>("-channels",0,3);}
or as \inlinecode{std::string}
\displaycode{Size size = translateSize(pa\_subarg<std::string>("-size",0,"VGA"));}. More information can be found in the documentation.

\subsection{Utility Structures}
Firstly, there are 3 main utility structures:
\begin{enumerate}
\item The \inlinecode{Size}-class (\iclclassref{Core}{Size}), which in substance consists of an \inlinecode{int}-width and -height parameter, represents e.g. image-, widget-, ROI,  or screen sizes.
\item The \inlinecode{Point}-class (\iclclassref{Core}{Point} ; and it's \inlinecode{float}-precision variation \inlinecode{Point32f}; \iclclassref{Core}{Point32f}), should be used to defined 2D-locations e.g. pixel locations, ROI-offsets or perhaps region-centers.
\item At last, the \inlinecode{Rect}-class (\iclclassref{Core}{Rect}; also available with floating point precision; \iclclassref{Core}{Rect32f}) with essentially combines a \inlinecode{Point} and a \inlinecode{Size} to represent rectangular regions, bounding-boxes, ROI's etc.
\end{enumerate}
All these classes are derived from corresponding IPP data types (\inlinecode{ippPoint}, \inlinecode{ippSize} and \inlinecode{ippRect}) in case of having IPP support, which enables the programmer to pass e.g. an \inlinecode{icl::Point} directly to an IPP-function.

\subsubsection{Lines}
The \inlinecode{Line} and \inlinecode{Line32f} classes (\iclclassref{Core}{Line}, and \iclclassref{Core}{Line32f}). Are provided not only as an interface for representing 2D-Lines given by two points. In actual fact, they provide an efficient mechanism to sample lines into an image grid using Bresenham's line algorithm\footnote{See \hrefn{http://de.wikipedia.org/wiki/Bresenham-Algorithmus}}.

\subsubsection{Ranges}
At last, there's a template class representing ranges: \iclstructref{Core}{Range} and it's extension \iclstructref{Core}{SteppingRange}.

\subsection{String-Utilities}
To facilitate string processing (which is still a bit complicated in C++), the header \iclheaderref{Utils}{StringUtils} is provided in the ICLUtils package. It contains functions to parse \inlinecode{std::strings} into given data types (template based, \inlinecode{T parse<T>(const std::string&)} and to convert given data-types into strings (\inlinecode{std::string str(const T&)}). Furthermore, there are variants of these functions, that work on \inlinecode{std::vector} instances to convert or parse ranges at once.\\
Moreover, ICL provides conversion functions to translate sizes, formats, depths etc. into strings and back. These functions are located in the \iclheaderref{Utils}{Utils} and their names are \inlinecode{translateSize}, \inlinecode{translateFormat} etc.

\subsection{Types}
Types and enumerations have been presented and discussed in section \ref{sec:typedef-confusions}. Types are declared in \iclheaderref{Utils}{BasicTypes}.

\subsection{XML-Parser}
To be able to use xml-data and configuration files without getting an extra software-dependency, ICL uses it's own simple XML-Parser. This of course entails some issues on the complexity of XML-files, that can be parsed. Actually, some features (like namespaces or XML-schematics) are just not supported at all. Furthermore, we limited XML-nodes to be be parent nodes (that have other child nodes) \textbf{or} \emph{text}-nodes that have a text content (maybe we have to fix that someday :-( ).\\
However, the XML-Parser works well for our purpose: It can be used to easily parse XML-documents or to query and filter nodes from the Documents tree structure. Furthermore, we use it successfully to create and to parse instances of the \inlinecode{ConfigFile} class, that provides hi convenience for using configuration files in applications (See \ref{subsec:config-file})

\subsection{Configuration Files\label{subsec:config-file}}
The \iclclassref{Utils}{ConfigFile}-class can be used to facility handling of dynamic configurable applications. Of course, one can make heavily use of program arguments, however this makes is difficult to save parameters or to distribute configuration parameters via revision control systems like e.g. subversion\footnote{\hrefn{http://de.wikipedia.org/wiki/Subversion\_(Software)}}. \inlinecode{ConfigFile} instances can be created very easily in the C++ source code, and their contents can be obtains very simply. Most of the time, a simple one-line statement is sufficient to get a certain entry at runtime. On the other side, the configuration file itself uses a simple XML-subset which facilitates both, parsing of the document as well as referencing entries non-ambiguously. Here's a tiny example:

\codefile{config.xml}{config.xml}

Corresponding source file:

\codefile{config-file.cpp}{ConfigFile use case}

And resulting configuration file:

\codefile{other.xml}{Written configuration file other.xml}


\section{ICLCore}

[Documentation: \iclpackageref{Core}]\\
The Core-package contains, apart from the image base class \inlinecode{ImgBase} and template classes \inlinecode{Img<T>}, fundamental image processing functions and utility classes. In particular, it contains the header \iclheaderref{Core}{Types}, that declares most common ICL data types and enumerations. Furthermore, there are mathematic functions, random number generators, utility functions for converting and copying images and some utility structures like rectangles, points and lines.

\subsection{Image classes}
The image classes have been described in detail in chapter \ref{cha:img-base-functions} and \ref{cha:img-class-functions}.


\subsection{Mathematic Functions}
Also some fundamental mathematic functionalities are provided in the package. The header \iclheaderref{Core}{Mathematics} contains some stochastic utility template functions for computation of mean, variance and standard derivation of a range. Also color-histogram calculating functions (\inlinecode{hist} and \inlinecode{channelHisto}) are available by including this header. More information can be obtained from the header documentation (mentioned above).

\subsection{Random Number Generators}
Formerly a part of the header \iclheaderref{Core}{Mathematics}-header, random number generators are not provided by the header \iclheaderref{Core}{Random}. Actually, only two different distributions are currently supported: uniform- and gaussian distribution. However a set of functions are provided for each distribution to facilitate random number (and random range) generation. \\
Firstly, there's an overloaded \inlinecode{randomSeed()} function, that can be used to initialize the systems random generator engine, with an optinal \emph{seed-value}. If no seed value is given, current system time is used for initialization. Furthermore, a class called \inlinecode{RandomSeeder} (\iclstructref{Core}{RandomSeeder}) is provided which can be instantiated on some stack to force random number generation engine initialization at program startup. \\
In Addition, there's a set of initializer functors (\iclclassref{Core}{URand},\iclclassref{Core}{URandI},\iclclassref{Core}{GRand} and \iclclassref{Core}{GRandClip}), that can be used e.g. with \inlinecode{std::fill} to initialize range elements randomly. 



\section{ICLCC\label{sec:cc}}

[Documentation: \iclpackageref{CC}]\\
The \textbf{C}olor \textbf{C}conversion package provides a powerful environment for converting images color formats. Additionally data layout conversion functions (\inlinecode{interleavedToPlanar} and \inlinecode{planarToInterleaved} are implemented in this package (available by including the \iclheaderref{CC}{CC}-header) and a powerful \inlinecode{Converter}-class (\iclclassref{CC}{Converter}), that allows convert images with different sizes, formats and depths\footnote{or even all at once} into each other while preserving image content.


\subsection{Color Conversion}

As illustrated in section \ref{sec:image-features} ICL images possess a \inlinecode{format} parameter that defines the images actual color format (e.g. RGB HLS or gray). As most algorithms process images regardless their color formats, color conversion was outsourced into the dedicated \iclpackageref{CC}-package. Basically, all color conversion algorithms are implemented with a single function called \inlinecode{cc} (also available in the \iclheaderref{CC}{CC}-header. \inlinecode{cc} is able to convert pixels from a source image into a given destination image. Source and destination color formats are extracted automatically from the given images. Optionally, \inlinecode{cc} can be setup to process an images ROI only.\\
Base format for color conversion is the \emph{sRGB}\footnote{\hrefn{http://en.wikipedia.org/wiki/SRGB}} format (represented by the \inlinecode{format}-enum value \inlinecode{formatRGB}). All other formats can be converted \emph{from} and \emph{into} the sRGB-format natively. Some other \emph{cross-conversions} are implemented by first converting source image pixels into sRGB, before conversion from sRGB into the desired destination format is available. The \iclheaderref{CC}{CC}-header provides a good overview of the implemented formats and their conversion performance.\\
If color conversion performance is not fast enough, it can be optimized using a lookup table, that can be created on automatically on demand by calling the \inlinecode{createLUT} function.\\
By the way, the color conversion function \inlinecode{cc} is implemented using massive template-expansion. This enables \inlinecode{cc} to perform a \inlinecode{depth}-conversion simultaneously (by the way, this is why \inlinecode{iclCC.cpp} needs that much time to compile).

\subsection{General Parameter Conversion}

If also an images size must be adapted, there's need for some temporary buffers. The \inlinecode{Converter} (\iclclassref{CC}{Converter}) class automatically handles internal buffers for \inlinecode{depth}-, \inlinecode{size}- and \inlinecode{format}-conversion. Furthermore it provides the ability to select the order of different conversion steps.
 

 
\subsection{Data Layout Conversion}

As motivated in chapter \ref{cha:what-is-the-icl}, ICL's images do always use planar data layout, however sometimes available image data is interleaved, or ICL-image data must be converted into interleaved data layout. The \iclheaderref{CC}{CC}-header also provides two conversion functions for this tasks: \displaycode{interleavedToPlanar}
\displaycode{planarToInterleaved}

Both functions are highly optimized and -- if supported -- IPP accelerated. Additionally, both functions are able to apply a \inlinecode{depth}-conversion too, and the provide source and destination ROI support. As there's no interleaved image format in the ICL, interleaved image data is always just represented by a single data pointer; the interleaved images ROI is determined from the given \inlinecode{lineStep} argument.





\section{ICLIO\label{sec:io}}

[Documentation: \iclpackageref{IO}]\\

The IO-package provides functions and classes for reading and writing image from- and to different devices. The most common interface is the \inlinecode{Grabber} (\iclclassref{IO}{Grabber}). All image input devices are implemented as specializations of this \inlinecode{Grabber}-class, which provides a generic interface for grabbing images and setting camera parameters and capture modes (see section \ref{sec:grabber-feature-adjustment}). Currently, the following grabbers are available:

\begin{enumerate}
\item \inlinecode{FileGrabber} [\iclclassref{IO}{FileGrabber}]:\\
 For reading image files in most different formats. .ppm, .pnm and .pgm as well as a special icl-format \emph{.icl} are implemented natively without any external software dependencies. .jpeg-files can be read with a wrapper of libjpeg. All other file-formats are passed to an libImageMagic++\footnote{\hrefn{http://www.imagemagick.org/Magick++/}}-wrapper (currently this supports about 100 more or less common file formats)
%
\item \inlinecode{DCGrabber} [\iclclassref{IO}{DCGrabber}]:\\
The \inlinecode{DCGrabber} grabs images from fire-wire aka IEEE-1394 camera devices. Basically it wraps the libdc1394 library\footnote{\hrefn{http://sourceforge.net/projects/libdc1394/}} for accessing cameras, that meet the IIDC DCAM standart\footnote{\hrefn{http://de.wikipedia.org/wiki/DCAM}}, and which gave the grabber it's name. DC-Camera features, image acquisition modes and framerates are made accessible via the Grabbers feature \emph{setter}- and \emph{getter}-functions.
%
\item \inlinecode{PWCGrabber} [\iclclassref{IO}{PWCGrabber}]:\\
The \textbf{P}hillips \textbf{W}eb\textbf{C}am grabber can be used to grab images from cameras that use the linux pwc kernel module\footnote{\hrefn{http://www.saillard.org/linux/pwc/}}.
\item TODO
\end{enumerate}

\subsection{Feature Adjustment\label{sec:grabber-feature-adjustment}}
TODO
