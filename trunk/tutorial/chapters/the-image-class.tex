Here is a short C++ scheme of the image structure\footnote{This is not the actual implementation, but it should work as a schematic summary of the image features.}.

\codefile{image-class-scheme-1.cpp}{image class scheme}


\section {Adjustment and Reinterpretion of Image Parameters}
At this point, it shall be mentioned, that some image parameters can be changed more easily\footnote{in terms of processing performance} then other ones. Changing an images size or channel count implies, that image data pointers must be allocated, free'd -- or even reallocated. Futhermore, we will see soon, that the whole image structure must be reallocated if the image depth is changed. However changing the other parameters is sometimes much cheaper: E.g. changing an images ROI or time stamp works without changing the image data itself. Also the image format can be changed as long as the new format is not associated with another channel count\footnote{Ok, reinterpreting an RGB-images channels as an YUV-data does not really make sense, except when the assumption of the RGB image format was already wrong. Most of the time, this feature is necessary to reinterpret matrix-format data into a color-/gray-format or vice versa}.\\
Futhermore, it's worth mention, that all image parameter manipulating functions do only work on demand. E.g. if \inlinecode{setSize} is called on an image that already has the desired size, nothing is done.


\subsection {Image Params Revised}
To simplify the image class implementation, we introduced a utility data structure called \inlinecode{ImgParams} \iclclassref{Core}{ImgParams}. This structure consists of size, channel count, format, and ROI. Besides, it handles correlation between channel count and format as well as checking and adapting ROIs, that do not fit into the whole image rect. The image itself contains an \inlinecode{ImgParams} structure, a time stamp and a depth variable. Futhermore, one can make two images \inlinecode{A} and \inlinecode{B} compatible (except their depth-values) by calling \inlinecode{B.setParams(A.getParams())}.


\section{The Image}
Now we are able to put these things together: image features and image data. As mentioned sometimes above, we use templating\footnote{For those who are not so familiar with C++ templates, Chapter \ref{cha:templating} shell help to recapitulate most common rules and features.} to avoid redundant implementation for images of different data types. This image class template is called \inlinecode{Img} \iclclassref{Core}{Img}. First, it's structure looked something like that:

\codefile{img-structure-with-params.cpp}{First prototype for \inlinecode{Img}-structure}

Those who are familiar with C++-templating techniques, might have mentioned, that there is still some overhead within the implementation. Although all parameters except the image data vector do not depend on the template parameter \inlinecode{T}, they are a part of each template instance.\\
Furthermore, there's a special problem regarding C++ template classes, which can easily be stated with the \inlinecode{Img}-example: different template instances (e.g. \inlinecode{Img<int>} and \inlinecode{Img<float>}) have no common data structure at runtime. So there's no higher-level structure which can be used as an interface for different \inlinecode{Img<T>}-classes.\\
This is why we decided to implement a base class for all \inlinecode{Img<T>} template instances called \inlinecode{ImgBase} \iclclassref{Core}{ImgBase}. Basically, \inlinecode{Img} and \inlinecode{ImgBase} are linked like this:

\codefile{img-and-img-base-scheme.cpp}{Inheritance scheme for \inlinecode{Img} and \inlinecode{ImgBase} classes} 


\section{Typedef-Confusions}
To facilitate handling ICL image template types, we provide a set of \inlinecode{typedef}s within the \iclheaderref{Core}{Types}-header. In the first instance, there's a set of \inlinecode{typedef}s for some C++-POD\footnote{Plain Old Data-Types like \inlinecode{int}, \inlinecode{unsigned char}, \inlinecode{float} etc...}-types:

\codefile{icl-D-typedefs.cpp}{ICL's POD-typedefs} 

As one can see, typedefs are made compatible to Intel IPP-typedefs in case of having IPP-support, otherwise according C/C++ types are used directly. Beyond that, by copying Intel IPP's type suffixes, we will be able to define macros that construct IPP function names dynamically.\\ Once having defined this types, also class instances of the \inlinecode{Img<T>}-template can be \inlinecode{typedef}'ed to more convenient typenames:

\codefile{img-D-typedefs.cpp}{ICL's Image-Types} 

To confuse the reader even a little more, also the runtime type identification \inlinecode{enum depth} uses the same type suffixes:

\codefile{icl-depth-enum.cpp}{The depth enumeration} 

All this types (or values in case of the \inlinecode{depth-enum}) engage during implementation, as the following section will illustrate. The \emph{take-home-message} of this section is:\\
\begin{itemize}
\item An \inlinecode{ImgX} uses \inlinecode{iclX}'s as pixel values.
\item \inlinecode{ImgX} is just a \inlinecode{typedef} for \inlinecode{Img<iclX>}.
\item An \inlinecode{ImgX}'s \inlinecode{getDepth()}-member function returns \inlinecode{depthX}, which is essential if you want to determine the actual type of an \inlinecode{ImgBase}-pointer or -reference.
\item Currently \inlinecode{X} may be \inlinecode{8u, 16s, 32s, 32f, 64f}.
\end{itemize}


\section{Implementing depth-independent functions}

At this point we are able to explain the necessity of the depth parameter in the \inlinecode{ImgBase} class in detail. Consider there is a function (e.g. named \inlinecode{threshold}) that shall work with arbitrary image depths, so it must expect an \inlinecode{ImgBase}-parameter\footnote{as pointer or reference as inheritance does not work otherwise}:

\displaycode{void threshold(ImgBase *image, double t);}

The depth parameter within the \inlinecode{ImgBase} serves as runtime type identifier to perform a save cast into the real data type at runtime.

\codefile{cast-imgbase-to-img-threshold-example.cpp}{Type-safe casting (downwards within the inheritance tree)}

Ok, probably there are some contradictions:\\

\begin{itemize}
\item \textbf{Type-safe casting downwards within the inheritance tree is already supported by the C++-RTTI\footnote{RunTime-Type-Identification}-interface}\\
Yes, it is, but it's very slow in comparison to comparing a single enumeration value. I figured out, that using \inlinecode{dynamic\_cast} instead of switching over the \inlinecode{depth enum} is about 20 times slower when compiling optimized.

\item \textbf{Function implementation gets very complicated and we cannot exploit the fact, that \inlinecode{Img} instances are templates}\\
No - and yes we can! The code above was just an example to explain how it can be implemented. A real implementation of an image threshold could look like this:

\codefile{cast-imgbase-to-img-threshold-example-real.cpp}{Type-safe threshold implementation revised}

\item \textbf{This helps only to exploit templating, switching over all types produces still a lot of code}\\
There is a special ICL-macro that helps to implement such \inlinecode{switch}-calls, which is called \inlinecode{ICL\_INSTANTIATE\_ALL\_DEPTHS}. This macro then calls another macro named \inlinecode{ICL\_INSTANTIATE\_DEPTH(D)}, which defines how process a specific depth -- and which must be defined by the programmer before \inlinecode{ICL\_INSTANTIATE\_ALL\_DEPTHS} can be called. \inlinecode{ICL\_INSTANTIATE\_ALL\_DEPTHS} then just expands to  \inlinecode{ICL\_INSTANTIATE\_DEPTH(8u)} \inlinecode{ICL\_INSTANTIATE\_DEPTH(16s)} etc. Of course \inlinecode{ICL\_INSTANTIATE\_DEPTH(D)} must be undefined after calling \inlinecode{ICL\_INSTANTIATE\_ALL\_DEPTHS} to allow to use this feature again later. The full threshold implementation could look like this\footnote{Ok, we use another macro called \inlinecode{ICL\_INVALID\_DEPTH} here, which just throws an appropriate exception}:

\codefile{cast-imgbase-to-img-threshold-example-macro.cpp}{Using the \inlinecode{ICL\_INSTANTIATE\_ALL\_DEPTHS}-macro}

\end{itemize}

\section {Shallow Copy Concept}

In contrast to e.g. Java, C++ copies all objects deeply on default. If a reference copy is desired (e.g. as function arguments) one can simply use the \inlinecode{&} character to make a function argument be copied by reference (shallowly). Unfortunately this mechanism cannot be transcribed to function return values. Return values are often temporary objects (that \emph{live} on the function stack) which cannot be passed by reference as return values. Hence, temporaries must:
\begin{enumerate}
\item be copied on the function return interface\footnote{There is a special case, when this isn't necessary, namely if the return values is stored in a brand new instance of that type, but often this is not appropriate.}
\item or be passed as a pointer (allocated on the heap)
\end{enumerate}
Copying data always involves a large overhead especially when large data arrays have to be copied deeply. If a function returns a pointer, there's always some implementational overhead for deleting the image pointer later on, however this could be forgotten accidently, which would leads to a memory leak then.\\
This is why we broke with the C++ convention of \emph{deep copy on default} for the image class:
\begin{center}
\textbf{images are copied shallowly on default!}\\[20pt]
\end{center}
More precisely, \textbf{image channel data} is copied shallowly, and all other image parameters are copied deeply. This can be interpreted as follows:
An \inlinecode{Img<T>} instance corresponds to a \textbf{view} on the underlying image channel data. This can be exploited e.g. by having an image \inlinecode{A} which has a full ROI\footnote{this means the ROI-rectangle has offset $(0,0)$ and it's size is similar to the image size.} and another image \inlinecode{B} with a distinct ROI and both images share their channel data. Futhermore this enables us to  construct an image from the channels of a set of other images, to flip image channels or to append image channels shallowly.\\
However there're of course situations where a deep copy is desired. This can either be done using the \inlinecode{deepCopy()}-function of an image or by calling the \inlinecode{detach()}-function on a shared image (see \iclclassref{Core}{Img} for details).

\codefile{shallow-copied-imgs.cpp}{Deep- and shallow copies of images}

\subsection{Drawbacks of Shallow-Copy-on-Default}
In short, actually C++ doesn't support shallow copy on default (SCOD) very well. Firstly, there's a C++ convention that says \emph{C++ uses deep copy on default (DCOD)}, so breaking with that convention must be documented well to avoid really unexpected behaviour. Besides, there's another problem with C++'s \inlinecode{const}-concept, which can only hardly be combined properly with SCOD classes. Consider there's a class \inlinecode{I} (e.g. an image class) that realizes SCOD, by implementing at least the copy constructor \inlinecode{I::I(const I&)} and the assignment operator (\inlinecode{I& I::operator=(const I&)}. Now, consider some function interface like \inlinecode{void foo(const I &i)}, which \emph{promises} not to change the function argument \inlinecode{i} due to it's \inlinecode{const}-ness. If the class \inlinecode{I} is implemented correctly it will ensure this actively, by \emph{denying} access to un-\inlinecode{const} member functions and un-\inlinecode{mutable} class members of \inlinecode{i} at compile time. Unfortunately, it's still possible to create an un-\inlinecode{const} shallow copy of \inlinecode{i} to do that nevertheless. All attempts to avoid this will fail, because it's not possible to restrict a shallow copying copy constructor to un-\inlinecode{const} source images or to enforce new shallow copied instances of \inlinecode{const} class instances to be \inlinecode{const}.\\
Hence, take care when you're copying \inlinecode{const Img<T>}-instances.



\section {Channel Management}

As mentioned above, also single channels can be shared by different \inlinecode{Img<T>} instances. Of course, this does only work for images with an identical depth ans size. The following example demonstrates channel management:

\codefile{channel-management.cpp}{Image channel management examples}


\section {Converting Images}

In some situations, incomming image depth is not sufficient for a certain task. There a two mechanism that may help in that situation:
\begin{enumerate}
\item Creation of another image with identical parameters except the first images depth, followed by a source-destination-fashioned pixel-wise conversion.
\item An \emph{inplace}-adaption of the image-depth, which is only possible for \inlinecode{ImgBase}-instances on the heap.
\end{enumerate}

This following two sub-sections   will show, how to convert an images depth (sec. \ref{subsec:depth-conversion}) and how to adapt an images depth \emph{inplace}(sec. \ref{subsec:depth-adaption}).

\subsection {\label{subsec:depth-conversion}Image depth-Conversion}
To avoid misunderstandings, there's another use for the term \emph{conversion}, namely for \emph{color conversion} which is discussed in section \ref{sec:color-conversion}.\\
Image depth conversion is alway applied deeply or pixel-wise, i.e. each single pixel is converted. Type to type conversion is applied with the \inlinecode{clipped\_cast()} template function (see \iclheaderref{Util}{ClippedCast}, that avoids range overflow if the destination data type has a smaller range than the source data type. \emph{Vectorized} conversion (converting a range of type \inlinecode{A} element-wise into a range of type \inlinecode{B} is done by the \inlinecode{convert}-function (\iclheaderref{Core}{Core}), which uses the STL-algorithm \inlinecode{std::transform} to apply \inlinecode{clipped\_cast} element-wise at default. However most\footnote{For most \inlinecode{iclXX} to \inlinecode{iclYY} combinations} common conversion operations e.g. from \inlinecode{icl32f} to \inlinecode{icl8u} are IPP-accelerated if IPP support is enabled.\\
The \inlinecode{ImgBase}-class provides three dedicated \inlinecode{convert} functions for converting image data. 
\begin{enumerate}
\item \inlinecode{Img<T>* ImgBase::convert(Img<T>*dst=NULL)const}\\
This function allows to specify destination depth from template scope. Furthermore, this templating mechanism automatically matches to the destination depth if \inlinecode{dst} is not \inlinecode{NULL}.
\item \inlinecode{ImgBase *ImgBase::convert(depth d) const}\\
This conversion function can be used if destination depth is not known at compile time.
\item \inlinecode{ImgBase *ImgBase::convert(ImgBase *dst) const}\\
This function extracts destination depth also at runtime from the given \inlinecode{ImgBase*}.      
\end{enumerate}


\subsection {\label{subsec:depth-adaption}Image depth-Adaption}

As mentioned above, due to the fact, that the \inlinecode{Img<T>} template class inherits the \inlinecode{ImgBase}-class, there's no \inlinecode{setDepth()}-member function within the \inlinecode{ImgBase} class. However in some situations an images depth must be adapted. This is why we need an concededly \emph{ugly} \inlinecode{ImgBase**} interface.

\codefile{img-base-naive-depth-adaption.cpp}{Naive depth adaption}

This can be achieved much easier using the \inlinecode{ensureDepth}-function (\iclheaderref{Core}{Core}). 
\inlinecode{ensureDepth} uses an \inlinecode{ImgBase**} parameter which allows that a re-allocation of the referenced \inlinecode{ImgBase*} is mentioned in the calling scope. Exceptionally\footnote{Actually this tutorial trys to explain ICL's-function interfaces rather than their current implementation.}, here's the implementation of ICL's \inlinecode{ensureDepth}-function:

\codefile{ensure-depth-implementation.cpp}{Actual implementation of \inlinecode{ensureDepth} function}

The \inlinecode{ImgBase**}-interface is used e.g. for the \inlinecode{Grabber}-interface (\iclclassref{IO}{Grabber}) and for unary- and binary operators (see \iclclassref{Filter}{UnaryOp} and \iclclassref{Filter}{BinaryOp}). To make things a bit more graphic, we risk a short anticipation to the \inlinecode{UnaryOp}-interface.\\
A unary image operator (represented by the \inlinecode{UnaryOp}-interface), can be seen as a \emph{black-box}, that has an image input and an image output and some functionality that transforms a given input image into the output image. Often this is referenced as an \emph{image-filter}, however we use the term \emph{unary operator} to emphasize, that there are binary operators as well with a different semantics. The unary operator interface consists essentially of a single function:

\displaycode{virtual void apply(const ImgBase *src, ImgBase **dst)=0}

This function \emph{applies} the operators functionality to the input image \inlinecode{src} and stores the result to the output image \inlinecode{dst}. All ICL-operators will adapt the output image automatically in terms of size, channel count, format, ROI, time stamp and even depth. The following example shows how to use a convolution-operator within a looped application:

\codefile{unary-op-loop-example.cpp}{Using unary operators in a loop} 

Please notice, that \inlinecode{dst} is used within the loop. The apply function of \inlinecode{ConvolutionOp} adapts \inlinecode{dst} if necessary, otherwise, it just re-uses \inlinecode{dst}. By this means \inlinecode{dst} is just allocated once, unless input image parameters aren't constant.


\section{Futher ImgBase-functions}


\begin{itemize}
\item \inlinecode{convertROI(..)}\\
An image conversion with \inlinecode{ImgBase::convert()} doesn't work on images ROI only. It's semantics is to create anned using one of the three \inlinecode{ImgBase::convertROI()}-functions, which behave identical to the corresponding \inlinecode{convert}-functions, except they use the input images ROI only. This implies, that a \inlinecode{convertROI}-call on a \emph{full-ROI'ed} image is semantically identical to a \inlinecode{convert}-call.
\item \inlinecode{scaledCopy()} and \inlinecode{scaledCopyROI()}\\
This two function families can be used to create scaled instances of an image. Scaling can be performed using one of three different interpolation techniques. The interpolation method can be set using the \inlinecode{scalemode}-enumeration \iclheaderref{Core}{Types}):
\begin{enumerate}
  \item Nearest-neighbour (\inlinecode{scalemode} value \inlinecode{interpolateNN}:  Simple, but very fast\footnote{More details can easily be found in the internet}.
  \item Linear (\inlinecode{scalemode} value \inlinecode{interpolateLIN}: More sophisticated, less moire-effects, softer edges in case of up-scaling.
  \item Region-Average: (\inlinecode{scalemode} value \inlinecode{interpolateRA}: Only for downscaling, only available with IPP-Support, best results for downscaling.  
\end{enumerate}
Again \inlinecode{scaledCopyROI} scales the source ROI only, and results in a full-ROI'ed image, whereas \inlinecode{scaledCopy} scaled the whole image including it's ROI.
\item \inlinecode{asImg<T>()}-template function:\\
This is a utility function that helps to apply a safe cast on an \inlinecode{ImgBase}-image into a certain \inlinecode{Img<T>*}. Internally the source images \inlinecode{depth}-values is checked to be equal to the desired depth. If this check fails, an error message is shown and a NULL-pointer is returned.

\end{itemize}

\subsection{Statistic Functions}
Actually we didn't want to implement these functions as member functions, because it's really hard to decide, which functions are \emph{fundamental enough} for becoming an image member function, and which others are not. However, it turned out, that at least obtaining an images minimum and maximum pixel value (and location) must be accessible directly. Hence there's a set of member functions \inlinecode{getMin}, \inlinecode{getMax} and \inlinecode{getMinMax} in the \inlinecode{ImgBase}-class. All these functions return \inlinecode{icl64f} values results, although internal calculation is performed on the native image data type. The use of \inlinecode{icl64f} enables us to provide this function already in the ImgBase class.

\subsection{Inplace Adaption Functions}
This functions directly adapt an images parameters and/or it's pixel values:
\begin{itemize}
\item The \inlinecode{scale()}-function resizes the images internally by reallocating a new image with desired size, scaling itself into this new image using the given interpolation method and assigning itself with that new image. As new data is allocated and old data is freed, this function has a relative poor performance.
\item \inlinecode{mirror()} can be use to flip one (or even both) image axis in-place. As this is done by swapping pixels, this function is quite fast. In addition, \inlinecode{mirror} can be setup to work on the images ROI only.
\item The \inlinecode{clear()}-function can be used to fill all image pixels with a given value. If the given channel argument isn't $-1$, the operation is only applied on the given channel. Additionally, it can be setup to clear the images ROI only.
\end{itemize}

\subsection{Normalization functions}
\begin{itemize}
\item \inlinecode{normalizeChannel}
\item \inlinecode{normalizeAllChannels}
\item \inlinecode{normalizeImg}.
\end{itemize} 
\emph{Normalization} means transforming the value range of an image by a linear function $f(x)=mx+b$, to make the resulting value range fit into a given intervall. E.g. this can be used to \emph{rescale} a floating input image with range $[0,1]$ into ICL's default value range $[0,255]$ by choosing $m=255$ and $b=0$. \\
All these functions can be used to normalize image values to a certain range. \inlinecode{normalizeChannel} and \inlinecode{normalizeImg} can be called with single \inlinecode{Range64f} (\iclclassref{Core}{Range}) only. In this case, the images source range is obtained using \inlinecode{getMinMax}. If otherwise, the source range is given, this step can be skipped. \inlinecode{normalizeAllChannels} applies normalization channel by channel whereas \inlinecode{normalizeImg} estimates the source range by computing the range of all channels.

\subsection{Utility functions}
\inlinecode{isEqual()} can be used to compare image parameters. \inlinecode{print} prints image parameters and channel value ranges to std::cout\footnote{Please note that an ImgBase-reference can also be \emph{streamed} into an C++-\inlinecode{std::ostream}}. The \inlinecode{isIndependent()} function returns true if the reference counter of all channel data pointers is one\footnote{I.e. these channels are currently not \emph{shared} with another image}.

\section{Pixel Access Function (in the Img-Template)}


The \inlinecode{Img<T>}-template class provides all image functions, that allow direct access to the pixel data. There are several mechanisms to obtain read- and write access to image pixels, which are introduced in the following sub sections. For comparison, each technique is used to implement a simple threshold operation on an \inlinecode{Img8u}-source image. Additionally some benchmark results are provided to compare the performance of the presented techniques. All these benchmarks were applied on a 2GHz Core-2-Duo machine, with a VGA-sized three channel image.

\subsection{Operator()(x,y,channel)\label{sec:x-y-channel-operator}}
Regarding the \emph{image function} (see section \ref{sec:the-image-function}), the \inlinecode{()}-operator with three parameters is the most intuitive way to access pixel data, however it's quite slow in comparison to other pixel access functions. In the \inlinecode{Img<T>} template class, image data is stored using a managed pointer type called \inlinecode{SmartPtr} \iclclassref{Utils}{SmartPtr}. This implies the following steps for the \inlinecode{()(x,y,channel)}-operator implementation:
\begin{enumerate}
\item Find the correct \inlinecode{SmartPtr} for the given channel argument.
\item Dereference the \inlinecode{SmartPtr} to get access to it's wrapped data pointer.
\item Calculate data pointer offset using \inlinecode{x + image.getWidth()*y}
\item Dereference the data pointer at that offset.
\end{enumerate}
Although all these steps are implemented inline to allow the compiler some optimizations, performance is quite poor:

\codefile{threshold-1.cpp}{Naive threshold implementation using the function-operator}

However, this code can easily be optimized to double it's performance:

\codefile{threshold-1b.cpp}{Optimized threshold implementation using the function-operator}

Here, the outer loop iterates though the image channels, which enables the compiler to optimize cache flow due to the planar data layout of our images. Furthermore, performance is enhanced significantly by calling the \inlinecode{(x,y,channel}-operator only once per pixel and channel. Besides the \inlinecode{:?}-operator can be replaced by \inlinecode{255*(pix>t)} here, which leads to less code branching.

\subsection{PixelRef-Type -- Operator()(x,y)}

The \inlinecode{()}-operator is overloaded. If the channel argument is omitted, it returns a special \inlinecode{PixelRef} \iclclassref{Core}{PixelRef} type, that references all channels at the given location at once. It's implemented as a C++-template to support image pixel types natively. It must be mentioned that this is also not the fastest technique for image pixel access.

\codefile{threshold-2.cpp}{Pixel access with the PixelRef type}

Ok, the \inlinecode{PixelRef}-classes performance is even worse, so it's existence must be justified here. It can e.g. be used to copy one pixel (e.g. RGB) of one image into another one, particularly when performance is negligible e.g. when processing mouse-clicks or in offline- or prototyping applications.However it provides simple access to whole image pixels at once with simple code, e.g: 
\displaycode{imageA(4,3) = imageB(12,3);} 



\subsection{Iterators and ROI-Iterators}

Iterators can be used to access pixel values successively. There are two different iterator types that can be obtained from \inlinecode{Img<T>}-instances. The \emph{normal} iterator is just an ordinary data pointer and it provides STL-style data access via  \inlinecode{begin()} and \inlinecode{end()}. As image data is split into channels, it's of course not possible to provide an efficient iterator running from the upper left pixel of channel $0$ to the lower right pixel of the last image channel. Instead, \inlinecode{begin()} and \inlinecode{end()} must be called with a channel argument.\\
The second iterator uses a special structure called \inlinecode{ImgIterator} \iclclassref{Core}{ImgIterator}. It provides a highly optimized interface to iterate over an images ROI only. Such ROI-iterators can be obtained using \inlinecode{beginROI(channel)} and \inlinecode{endROI(channel)}. Internally, each increment-operation must check for being on the right-hand side of the current image ROI to estimate the actual pointer increment. The optimized implementation uses a special g++ feature\footnote{This is also accessible using the \inlinecode{ICL\_UNLIKELY}-macro \iclheaderref{Utils}{Macros}} that allows the compiler to optimize pipelining due to the prior knowledge of a really unexpected entering of an \inlinecode{if}-body.\\
Of course, the benchmarking functions above are currently not implemented with ROI support, but this would not affect their performance due to their \inlinecode{x-y}-style implementation. 

\codefile{threshold-3.cpp}{Iterator based pixel access}

The upper function in this code section is also used for the function with ROI support\footnote{C++-templates rock!}.

\codefile{threshold-3b.cpp}{Iterator based pixel access with ROI support}

Please note, that the iterator based implementation runs nearly 10 times fastern then using the \inlinecode{(x,y,channel)}-operator and more than 30 times faster than the \inlinecode{(x,y)}-operator. Furthermore it's really interesting, that ROI support doesn't decrease performance significantly.\\
Lastly it's worth mention, that iterator based pixel access profits from compiler-performed loop unrolling\footnote{g++-flag -funroll-loops}. If this feature is enabled, computation time drops from 0.96 ms to 0.75 ms.

\subsection{Image Channel}
Image channels can be used, to accelerate channel data access significantly in comparison to the \inlinecode{(x,y,channel)}-operator while preserving convenience of use. As explained in section \ref{sec:x-y-channel-operator}, the \inlinecode{(x,y,channel)}-operator has to apply a lot of operation to get access to the pixel data pointer itself. As image data is stored in a dynamic array\footnote{Actually in a \inlinecode{std::vector<SmartPtr<T>>}} there're optimization opportunities for the compiler.

\codefile{threshold-4.cpp}{Image channel based pixel access}

Performance is still not so good, however we must regard that image channels should be used to get random \inlinecode{(x,y)}-access. If linear access is desired, image channels can also be used for linear data access:

\codefile{threshold-4b.cpp}{Using image channel for linear data access}

Here, we approach performance of the iterator based pixel access.



\subsection{Higher-Order templates (ForEach...)}
                                   
Now we approach the real cool stuff :-). Those who are familiar with the STL-algorithm package will supposably have become a fan of \inlinecode{std::for\_each} and \inlinecode{std::transform}\footnote{available in the \inlinecode{<algorithm>} header}. The \inlinecode{Img<T>} template class also provides such cool function templates. 
\begin{itemize}
\item \inlinecode{forEach} can be used to apply a function or a functor on each pixel separately. The pixel function gets only a single argument, so it can be used simply to apply inplace-pixel transformations, however arbitrary functions can of course be implemented theoretically due to the used of arbitrary functor objects. But there are better ways for other functionalities.
 
\item \inlinecode{transform} gets an additional destination image argument to store results in that image.

\item \inlinecode{combine} gets two additional arguments. It can be used to combine two images pixel-wise and by storing the result in another image. E.g. to compare two images pixel-wise.
\item \inlinecode{reduce\_channels} can be used to apply a function on all image channels simultaneously. Furthermore also all channels of the destination image are available in the iterated function. For more details take a look into the function documentation.
\end{itemize}

Internally all this functions provide optimized ROI support by processing image ROI's line by line. Lines are processed by passing the given fuctor to an appropriate STL-algorithm.  

\codefile{threshold-5.cpp}{Use of Img::forEach for an image threshold operation}


\subsection{Raw-Data Access}


\subsection{Using an Intel-IPP Function}



\section{Additional Functions in the Img-Template}






