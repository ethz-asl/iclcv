RH:
I changed already ROI data storage to use ICLpoint and ICLsize structs.
In order to become thread-safe, filter operations should not actually change
the source images ROI, but assume its own, eventually modified version.
For this purpose roiData (iChannel, ICLpoint* poOffset=0) provides an additional
default argument (poOffset) now. This is already changed for IPP version
of ICLMedian and ICLConvolution.

What should be done for the fallback solution, i.e. ICLIterator???
I would suspect, this needs change as well.


I would be nice to replace the filter macros by template functions.
Then, each filter class could implement a static function array and
directly call the correct function matching the current image depths.
Example:

template <typename ImgType>
class IPPMedian {
public: 
   static void apply (ICLBase* poSrc, ICLBase* poDst);
};
void IPPMedian<iclbyte>::apply (ICLBase* poSrc, ICLBase* poDst) {
   for(int c=0; c < poSrc->getChannels(); c++) {
      ippiFilterMedian_8u_C1R(poSrc->roiData8u (c, &poDst->getROIOffset()), poSrc->ippStep(),
                              poDst->roiData8u (c), poDst->ippStep(), poDst->getROISize(), 
                              oMaskSize, oAnchor);
   }
}

template <typename ImgType>
class CMedian {
public: 
   static void apply (ICLBase* poSrc, ICLBase* poDst);
};
template <T>
void CMedian<T>::apply (ICLBase* poSrc, ICLBase* poDst) {
   for(int c=0; c < poSrc->getChannels(); c++) {
      ...
   }
}

static ICLMedian::aMethods[2] = {IPPMedian<iclbyte>::apply, CMedian<iclfloat>::apply};
ICLBase* ICLMedian::apply (ICLBase* poSrc, ICLBase* poDst) {
   FUNCTION_LOG("");

   poDst = prepare (poSrc, poDst);
   if (!adaptROI (poSrc, poDst)) return poDst;

   aMethods[poSrc->getDepth()](poSrc, poDst);
   return poDst;
}

/**
evtl: 
apply(ICLBase *poSrc, ICLBase **ppoDst); --> das hätte dann zur folge, dass prepare auch 
                                             mit angepasst werden müsste

am besten dann prepare macht adapt roi gleich mit
*/


Noch schöner wäre es, wenn man für die Typdifferenzierung nicht die Hilfsklasse
bräuchte, sondern direkt template-Methods in einer nicht-template Klasse
machen könnte:
template<typename T>
void applyFilter (ICLBase* poSrc, ICLBase* poDst);

aMethods[2] = {applyFilter<iclbyte>, applyFilter<iclfloat>};
aMethods[poSrc->getDepth()](poSrc, poDst);

Wenn das ginge, könnten diese Methoden auch auf Member-Variablen der Klasse
zugreifen und man könnte sinnvoller Weise die Schleife über die Channels in
die apply-Methode hochziehen. Die Funktionspointer könnten dann direkt
mit IPP-Funktionen bzw. den Fallback-Funktionen (mit gleichem Interface) belegt
werden. Dazu müssten dann die Klassen-Methoden als "normale" Funktionen
zugreifbar werden.
In der std oder mindestens in boost gibt es aber Funktoren, die aus
Klassen-Methoden klassenunabhängige Funktionen machen, indem sie die
zugehörige Objektinstanz mitspeichern. 



  /*NEU*/
  ICL::begin() ersetzen durch getIterator() und getROIIterator(); /// ok!

  /**
  ImgI Q
  OLD:::::::::::::::::::::::::::::::::::::::::::::::::::::. ab hier
  */
Hi Robert,

habe soeben mal die Änderungen an den ICLBase / ICL Interface begutachtet.

Positiv:
---------
Das Verwenden der structs ICLpoint und ICLsize macht den Umgang in viele Situationen
sicherlich einfacher, und es ensteht nicht das Problem mit dem Größen-Check des verwendeten
Vektors.

Nicht so gut:
-------------
finde ich, dass (nicht nur dadurch) das Klassen Interface ein wenig fragmentiert geworden ist, da
  -  zum einen sehr viele unterschiedliche ROI Funktionen zur Verfügung stehen
     welche größtenteils redundante Zugriffe realisieren.
  -  nicht so wirklich klar ist, was nun im ippInterface ist, und was nicht.
  -  sehr viele unterschiedliche Funktionen zur Verfügung stehen um an die daten zu kommen

Mein Vorschlag um das Klasseninterface zu vereinfachen:
-------------------------------------------------------
von den ippXXX Funktionen  sind ja eh nicht mehr viele übrig geblieben -- dann werfen wir die doch
einfach ganz raus!

1.)wir führen noch einen neuen Typ ein:
#ifdef WITH_IPP_OPTIMIZATION
typedef IppiRect ICLRect;
#else
typedef struct ICLrect_ {int x,y,width,height;} ICLrect;
#endif

2.) der interne Speicher der ROI wird in einen rect struct gespeichert
ICLrect m_oROI;
// besser als size und offset behalten

3.) das Interface beschränken wir dann auf
const ICLrect& getROI() const;   // kann dann auch in ipp-funktionen eingesetzt werden
ICLpoint getROIOffset() const;   // hier wird ein neues object zurückgegeben
ICLsize getROISize() const;      // hier auch
//------------------------------------------------
void setROI(const ICLRect &roROI);
void setROIOffset(const ICLPoint &roOffset);
void setROISize(const ICLsize &roSize);

(klar, wenn nicht die komplette ROI verwendet wird, müssen Daten erstellt und
kopiert werden, aber ich glaube bei diesen [int,int]-structs wird dass die performanz
kaum - wenn nicht garnicht - beinflussen.)


4.)Aufrämen der vielen unterschiedlichen getDataXXX - funktionen

ICLBase:
--------
virtual void getDataPtr(int iChannel) = 0; // wie bisher implementiert in der ICL<Type>
void getROIDataPtr(int iChannel) {
  return ((unsigned char*)getDataPtr()) + (m_oROI.x + m_oSize.width * m_oROI.y) * byte_per_pixel;
}
void getROIDataPtr(int iChannel, const ICLpoint &roOffset) {
  ...
}

void tu_was_mit_ipp(ICLBase *p, int channel){
     if(p->getDepth()==depth8u){
        ippiSowiso(p->getROIData8u(channel),...);
     }else{
        ippiSowiso(p->getROIData32f(channel),...);
     }
}

void tu_was_mit_ipp_NEU(ICLBase *p, int channel){
     if(p->getDepth()==depth8u){
        ippiSowiso(p->asICL8u()->getROIData(channel),...);
     }else{
        ippiSowiso(p->asICL32f()->getROIData(channel),...);
     }
}
// Sehr gut! Ich bin dafür alle auf 8u/32f Funktionen zu ersetzen:
asIcl8u/32f -> asIcl<iclbyte> / asIcl<iclfloat>
// eventuell trotzdem alias behalten?

/***
convertToICL<T>
asICL<T>

*/

ICL<Type>:
---------
virtual void* getDataPtr(int iChannel){
   return getData();
}
T* getData(int iChannel) {
   return m_vecChannels[iChanel].get();        
}
T* getROIData(int iChannel){
   return getData() + m_oROI.x+m_iWidht*m_oROI.y;
}
T* getROIData(int iChannel, const ICLpoint &roOffset){
return getData + roOffset.x+m_iWidht*roOffset.y;   /// hier rein!
}
// ich fände hier die  "const ICLpoint &roOffset" - variante besser als die mit den "const ICLpoint *"
// da dieses dann konsitent zu den anderen ROI-funktionen bleibt. OK.
// virtual methods können nicht inline aufgelöst werden, deshalb der Vorschlag, getDataPtr ist alias
// für getData.
// Ok.

5.) Anschliessend müssen noch die letzen ippXXX - Funktionen rausgeworfen und
durch entsprechende nicht "NUR-ipp" Funktionen ersetzet werden.

int ippStep() const; wird ersetzt durch        int getLineStep() const; // oder so
IppiSize ippSize() const; wird ersetzt durch   ICLsize getSize() const;
// Nur konsequent.

6.) vielleicht noch zusätzlich;
(ist nur ein vorschlag, hat nichts mit dem Rest zu tun)

aktuell:
ICL32f *convertTo32Bit(ICL32f *poDst);
ICL8u *convertTo8Bit(ICL8u *poDst);
ICL32f *asIcl32f();
ICL8u *asIcl8u();

die convert-funktionen haben den großen Nachteil, dass 32Bit in dem Funktionsnamen
spätestens Probleme bringt, wenn wir auch noch ICL<int> erzeugen wollen.
daher wäre mein Vorschlag:
ICL32f *to32f( ICL32f *poDst );
ICL8u *to8u( ICL8u *poDst ); // also besser mit convertXXXX
ICL32f *as32f();
ICL8u *as8u();
// Korrekt. Siehe oben convertToIcl<iclfloat|iclbyte>

sind 'nen Haufen Änderungen -- vielleicht findest Du ja auch ein paar 
Aspekte davon Sinnvoll. Am besten wir besprechen alles noch mal am Montag 
zu dritt.

viele liebe Grüßee,
Christof
